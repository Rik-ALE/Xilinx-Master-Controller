#include <stdio.h>
#include "platform.h"
#include "xparameters.h"
#include "sleep.h"
#include "vpattern_gen.h"
#include "xil_printf.h"

#include "xil_types.h"
#include "xstatus.h"
#include "xil_io.h"
#include "xtime_l.h"


////////////////////////////////////////////////////////////////
// xparameters.h generation by SDK is buggy !
// it's not able to get correctly the base address of the pattern gen
// from the hdf generated by Vivado so it puts a dummy base address
// instead : 0xFFFFFFFF !!
//
// SO , I redefine here the correct base address for the IP instead of patching
// xparameters.h at each platform generation
////////////////////////////////////////////////////////////////
#define MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR 0x43C20000

int main()
{
	long pattern_mode;
	char choice='0';

	init_platform();
	// Main test loop
	 do
	   {
	    // Nice working Clear Screen Ansi Escape sequence code
	    // http://stackoverflow.com/questions/1348563/clearing-output-of-a-terminal-program-linux-c-c
	    xil_printf("\033[2J\033[1;1H");
	    xil_printf("----------------------------------------------\n\r");
	    xil_printf("-- VGA PATTERN TEST FUNCTIONS              --\n\r");
	    xil_printf("----------------------------------------------\n\r");
	    xil_printf("-- Teraterm : 115200/8/none/1 stop/No flow  --\n\r");
	    xil_printf("-- VT100/ Rcv = CR Tmit = CR+LF/ Local Echo --\n\r");
	    xil_printf("----------------------------------------------\n\r");
	    xil_printf("-- (0) : Use AXIStream2Video synchro        --\n\r");
	    xil_printf("-- (1) : Use Alternate synchro (timing gen) --\n\r");
	    xil_printf("-- (2) : Passthrough                        --\n\r");
	    xil_printf("-- (3) : Solid (White if no color cut)      --\n\r");
	    xil_printf("-- (4) : 8 bars                             --\n\r");
	    xil_printf("-- (5) : horizontal pattern                 --\n\r");
	    xil_printf("-- (6) : Keep Red, Cut Green & Blue         --\n\r");
	    xil_printf("-- (7) : Keep Green, Cut Red & Blue         --\n\r");
	    xil_printf("-- (8) : Keep Blue, Cut Red & Green         --\n\r");
	    xil_printf("-- (9) : No color cut                       --\n\r");
	    xil_printf("-- (x) : Exit                               --\n\r");
	    xil_printf("----------------------------------------------\n\r");
	    xil_printf("choice : ");
	    choice=getchar();

	    switch (choice)
	     {
	      case ('0'):
		  pattern_mode = VPATTERN_GEN_mReadReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET);
	      pattern_mode = pattern_mode & ~(0x4); // forcage a 0 de synchro_select
	      VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET, pattern_mode);
	      break;

	      case ('1'):
		  pattern_mode = VPATTERN_GEN_mReadReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET);
	      pattern_mode = pattern_mode | 0x4; // forcage a 1 de synchro_select
	      VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET, pattern_mode);
	      break;

	      case ('2'):
		  pattern_mode = VPATTERN_GEN_mReadReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET);
	      pattern_mode = pattern_mode & ~(0x3); // forcage a 0 de mode
	      VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET, pattern_mode);
	      break;

	      case ('3'):
		  VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG1_OFFSET, 0x00FFFFFF);
		  pattern_mode = VPATTERN_GEN_mReadReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET);
	      pattern_mode = pattern_mode & ~(0x3);
	      pattern_mode = pattern_mode |   0x1;  // forcage a 1 de mode
	      VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET, pattern_mode);
	      break;

	      case ('4'):
		  pattern_mode = VPATTERN_GEN_mReadReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET);
	      pattern_mode = pattern_mode & ~(0x3);
	      pattern_mode = pattern_mode |   0x2;  // forcage a 2 de mode
	      VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET, pattern_mode);
	      break;

	      case ('5'):
		  pattern_mode = VPATTERN_GEN_mReadReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET);
	      pattern_mode = pattern_mode |   0x3;  // forcage a 3 de mode
	      VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET, pattern_mode);
	      break;

	      case ('6'):
		  pattern_mode = VPATTERN_GEN_mReadReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET);
          pattern_mode = pattern_mode & ~(0xE0);
	      pattern_mode = pattern_mode |   0x60;  // forcage a xx6x de mode
	      VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET, pattern_mode);
	      break;

	      case ('7'):
		  pattern_mode = VPATTERN_GEN_mReadReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET);
          pattern_mode = pattern_mode & ~(0xE0);
	      pattern_mode = pattern_mode |   0xA0;  // forcage a xxAx de mode
	      VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET, pattern_mode);
	      break;

	      case ('8'):
		  pattern_mode = VPATTERN_GEN_mReadReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET);
          pattern_mode = pattern_mode & ~(0xE0);
	      pattern_mode = pattern_mode |   0xC0;  // forcage a xxCx de mode
	      VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET, pattern_mode);
	      break;

	      case ('9'):
		  pattern_mode = VPATTERN_GEN_mReadReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET);
          pattern_mode = pattern_mode & ~(0xE0);// forcage a xx0x de mode
	      VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET, pattern_mode);
	      break;

	     }

	   }
	  while (choice != 'x');

	  xil_printf("Done... Goodbye");
	  cleanup_platform();
	  return 0;




/*    xil_printf("\033[2J\033[1;1H");
    xil_printf("----------------------------------------------\n\r");
    xil_printf("-- ZYNQ VIDEO FIRST TEST                    --\n\r");
    xil_printf("----------------------------------------------\n\r");


    xil_printf("Testing pattern generator : \n\r");
    xil_printf("Due to the fact that AXIStream2Video don't output any sync before getting some axistream \n\r");
    xil_printf("The pattern generator use an alternate source for video sync \n\r");
    xil_printf("   - Solid : Red\n\r");
    VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG1_OFFSET, 0x00FF0000);
    VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET, 0x05);
    usleep(5000000);

    xil_printf("   - 8 bars \n\r");
    VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET, 0x06);
    usleep(10000000);
    xil_printf("   - Pattern and color cut \n\r");
    VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET, 0x07);
    usleep(2000000);
    VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET, 0xC7);
    usleep(2000000);
    VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET, 0xA7);
    usleep(2000000);
    VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET, 0x67);
    usleep(2000000);
    xil_printf("   - Solid : Black \n\r");
    VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG1_OFFSET, 0x00000000);
    VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET, 0x05);
    usleep(5000000);
    xil_printf("   - PassThrough\n\r");
    VPATTERN_GEN_mWriteReg(MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR, VPATTERN_GEN_S00_AXI_SLV_REG0_OFFSET, 0x00);
    usleep(3000000);

    xil_printf("\nDone... Goodbye\n");
    cleanup_platform();
    return 0;
    */


}
