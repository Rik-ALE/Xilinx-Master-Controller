#include <stdio.h>
#include "platform.h"
#include "xparameters.h"
#include "sleep.h"
#include "vpattern_gen.h"
#include "registers.h"
#include "xil_printf.h"

#include "xil_types.h"
#include "xstatus.h"
#include "xil_io.h"
#include "xtime_l.h"
#include "xil_cache.h"

////////////////////////////////////////////////////////////////
// xparameters.h generation by SDK is buggy !
// it's not able to get correctly the base address of the pattern gen
// from the hdf generated by Vivado so it puts a dummy base address
// instead : 0xFFFFFFFF !!
//
// SO , I redefine here the correct base address for the IP instead of patching
// xparameters.h at each platform generation
////////////////////////////////////////////////////////////////
#define MY_XPAR_VPATTERN_GEN_0_S00_AXI_BASEADDR 0x43C20000

#define MY_XPAR_REGISTERS_0_S00_AXI_BASEADDR    0x43C00000
#define ADR_SOURCE_OFFSET                       0
#define ADR_DEST_OFFSET                         4
#define SIZE_OFFSET                             8
#define CTRL_OFFSET                             12
#define STATUS_OFFSET                           32


#define DDR_BUFFER_SIZE        1024*1024 // 1 Mb buffer
//#define DDR_BUFFER_SIZE        64 // 64 bytes buffer for test

volatile u32 ddr_buffer[DDR_BUFFER_SIZE/4] = {0}; // .bss

int main()
{
	int      Status;
	volatile u32 Data = 0;
	u32      Addr,Pointer;

	init_platform();

    // Nice working Clear Screen Ansi Escape sequence code
    // http://stackoverflow.com/questions/1348563/clearing-output-of-a-terminal-program-linux-c-c
    xil_printf("\033[2J\033[1;1H");
    xil_printf("--------------------------------------------------------------------------------------------\n\r");
    xil_printf("-- SHARED MEM TEST                                                                        --\n\r");
    xil_printf("--------------------------------------------------------------------------------------------\n\r");

	xil_printf("\n\r");
	xil_printf("-------------------------------------------\n\r");
	xil_printf("-- 1ST STEP : Simple master config       --\n\r");
	xil_printf("-------------------------------------------\n\r");
	xil_printf("Slave Interface Base Address : 0x%x. \n\r",XPAR_SIMPLE_AXI_MASTER_0_S00_AXI_BASEADDR);
	for (Addr = XPAR_SIMPLE_AXI_MASTER_0_S00_AXI_BASEADDR; Addr < XPAR_SIMPLE_AXI_MASTER_0_S00_AXI_BASEADDR+16; Addr+=4)
    {
    	Data = Xil_In32(Addr);
    	xil_printf("Address : 0x%x => Read DATA : 0x%x \n\r",Addr,Data);
    }

	xil_printf("Base Address of allocated memory zone : 0x%x. \n\r",ddr_buffer);
	xil_printf("Now initializing base address register with that address. \n\r");
	Addr = XPAR_SIMPLE_AXI_MASTER_0_S00_AXI_BASEADDR+8; // 3rd reg @ address + 8
	Xil_Out32(Addr, (u32)ddr_buffer);
	xil_printf("And then enabling master interface (its BUSY signal shall fall). \n\r");
    Addr = XPAR_SIMPLE_AXI_MASTER_0_S00_AXI_BASEADDR+12; // 4th reg @ address + 12
	Xil_Out32(Addr, 1);

	Addr = XPAR_SIMPLE_AXI_MASTER_0_S00_AXI_BASEADDR+4; // 2nd reg @ address + 4
    xil_printf("Address : 0x%x (STAT)=> Read DATA : 0x%x \n\r",Addr,Xil_In32(Addr));
	Addr = XPAR_SIMPLE_AXI_MASTER_0_S00_AXI_BASEADDR+8; // 3rd reg @ address + 8
	xil_printf("Address : 0x%x (MBAD)=> Read DATA : 0x%x \n\r",Addr,Xil_In32(Addr));
	Addr = XPAR_SIMPLE_AXI_MASTER_0_S00_AXI_BASEADDR+12; // 4th reg @ address + 12
    xil_printf("Address : 0x%x (CTRL)=> Read DATA : 0x%x \n\r",Addr,Xil_In32(Addr));


	xil_printf("\n\r");
	xil_printf("-----------------------------------------------\n\r");
	xil_printf("-- 2ND STEP : filling data on DDR read zone  --\n\r");
	xil_printf("-----------------------------------------------\n\r");
	// DDR_BUFFER_SIZE is in bytes. we access 32 bits words => 4 bytes each time => /4 in the loop
	for (Pointer = 0; Pointer < DDR_BUFFER_SIZE/4; Pointer+=1)
	    {
		   ddr_buffer[Pointer] = (u32) Pointer+(Pointer<<16);
	    }
	// check back
	for (Pointer = 0; Pointer < DDR_BUFFER_SIZE/4; Pointer+=1)
	  {
	    if (ddr_buffer[Pointer] != Pointer+(Pointer<<16))
	    	{
	    	xil_printf("Element : %x => Readback DATA KO : %x \n\r",Pointer,ddr_buffer[Pointer]);
	    	}
	    // a few debug traces
	    if (Pointer % 4096 == 0)
	        {
	    	xil_printf("[DBG] Element : %x => Readback DATA : %x \n\r",Pointer,ddr_buffer[Pointer]);
	        }

	  }

	xil_printf("\n\r");
	xil_printf("-----------------------------------------------\n\r");
	xil_printf("-- 3RD STEP : start vhdl transfer            --\n\r");
	xil_printf("-----------------------------------------------\n\r");
	//xil_printf("VERY IMPORTANT : As the AXI master directly writes into DDR3 \n\r");
	//xil_printf("The ARM processor memory view gets outdated (it uses cache instead of real DDR3) \n\r");
	//xil_printf("To make it work correctly, the cache MUST be flushed just before making an access with the VHDL to DDR3 \n\r");
	//xil_printf("So let's flush before starting VHDL IP \n\r");
    //Xil_DCacheFlushRange((unsigned int)ddr_buffer,DDR_BUFFER_SIZE);
    xil_printf("\n\r");
    xil_printf("Starting VHDL IP \n\r");

    REGISTERS_mWriteReg(MY_XPAR_REGISTERS_0_S00_AXI_BASEADDR, ADR_SOURCE_OFFSET, 0);                 // source : buffer start
    REGISTERS_mWriteReg(MY_XPAR_REGISTERS_0_S00_AXI_BASEADDR, ADR_DEST_OFFSET  , DDR_BUFFER_SIZE/2); // dest : middle of buffer
    REGISTERS_mWriteReg(MY_XPAR_REGISTERS_0_S00_AXI_BASEADDR, SIZE_OFFSET      , DDR_BUFFER_SIZE/2); // size = 32 kB
    REGISTERS_mWriteReg(MY_XPAR_REGISTERS_0_S00_AXI_BASEADDR, CTRL_OFFSET      , 1);


    xil_printf("Waiting ");

    Status = 2;
    while(Status != 0)
    {
    	xil_printf(".");
    	Status = REGISTERS_mReadReg(MY_XPAR_REGISTERS_0_S00_AXI_BASEADDR, STATUS_OFFSET);
    }
    xil_printf("\n\r");
    REGISTERS_mWriteReg(MY_XPAR_REGISTERS_0_S00_AXI_BASEADDR, CTRL_OFFSET, 0);
	printf("Done \n\r");

	xil_printf("\n\r");
	xil_printf("-----------------------------------------------\n\r");
	xil_printf("-- 4th STEP : check dest zone                --\n\r");
	xil_printf("-----------------------------------------------\n\r");
	for (Pointer = 0; Pointer < DDR_BUFFER_SIZE/8; Pointer+=1)
	  {
	    if (ddr_buffer[Pointer] != Pointer+(Pointer<<16))
	    	{
	    	xil_printf("Source Element : %x => Readback DATA KO : %x \n\r",Pointer,ddr_buffer[Pointer]);
	    	}
	    // a few debug traces
	    if (Pointer % 4096 == 0)
	        {
	    	xil_printf("[DBG] Source Element : %x => Readback DATA : %x \n\r",Pointer,ddr_buffer[Pointer]);
	        }


	    // the vhdl IP should have make a copy of first half of buffer into second half
	    if (ddr_buffer[Pointer+(DDR_BUFFER_SIZE/8)] != Pointer+(Pointer<<16))
	    	{
	    	xil_printf("Dest Element : %x => Readback DATA KO : %x \n\r",Pointer+8192,ddr_buffer[Pointer+(DDR_BUFFER_SIZE/8)]);
	    	}
	    // a few debug traces
	    if (Pointer % 4096 == 0)
	        {
	    	xil_printf("[DBG] Dest Element : %x => Readback DATA : %x \n\r",Pointer+8192,ddr_buffer[Pointer+(DDR_BUFFER_SIZE/8)]);
	        }
	  }


    xil_printf("\nDone... Goodbye\n");
    cleanup_platform();
    return 0;

}
